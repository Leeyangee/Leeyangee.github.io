---
title: XYCTF & ISCC 个人部分题解
published: true
---

由于学业繁忙，没能亲身参加这两场比赛，仅作为场外援助试做了几道题  
因此笔者仅在这里仅写做出来了的题目  

| 目录跳转: |
|--------|
| [XYCTF MISC: 网络追踪](#题目-网络追踪) |
| [XYCTF MISC: game](#题目-game) |
| [ISCC MISC: 精装四合一](#题目-精装四合一) |
| [XYCTF 社工题: Osint2](#题目-osint2) |


# [](#header-1)MISC部分

### [](#header-31)题目: 网络追踪

根据题目描述：名为JFTQ的黑客使用某种不为人知的手段渗透进了一个不太安全的系统里  
那就说明攻击者应该是用nday打进去的  

首先，先过一遍流量包，发现从No.9441开始的tcp流`tcp.stream eq 4147`存在敏感的回显信息  
经过推测，黑客到这里应该已经上线了，由于这里的Shell是由192.168.204.133反弹给192.168.204.131的，那么可以判定192.168.204.133是受攻击者，192.168.204.131是攻击者

![avatar](/image/2024-05-01-1.png)  
![avatar](/image/2024-05-01-0.png)  

flag.txt为XXencode编码的信息，解码后如下所示
```
XYCTF{fake_flag}
真正的flag格式：XYCTF{靶机ip地址_nmap扫描出的靶机开放的端口(由大到小排列 中间用_进行连接)_获取靶机shell使用的漏洞的CVE编号}
例：XYCTF{1.1.1.1_888_88_8_CVE-2009-3103}
```

现在的目标是得知黑客扫出的哪些端口：直接在过滤器输入：`ip.src == 192.168.204.131 && ip.dst == 192.168.204.133`然后观察nmap包就行。如下图所示，黑客一共扫出来了445、139、135这几个端口

![avatar](/image/2024-05-01-2.png)  


最后的目标是得知黑客使用了哪个漏洞进入系统：分析一下上线前后的流量变化，上线前的最后一条流量是SMB协议的流量，且总的来说在上线前SMB协议的流量占比较多，那我就不得不盲猜应该是SMB服务的漏洞了。

![avatar](/image/2024-05-01-3.png)  

接下来直接在Bing上搜索关键词`smb历史漏洞`，点击第一篇"SMB漏洞汇总"博客把所有SMB历史洞都遍历一遍，最后试出来的结果是CVE-2008-4250

![avatar](/image/2024-05-01-4.png)  


完整的flag：`XYCTF{192.168.204.133_445_139_135_CVE-2008-4250}`

### [](#header-33)题目: game

![avatar](/image/2024-05-01-5.png)  

这个题直接谷歌识图就行了，一开始用bing和baidu识图均没出来还以为是解密题，没想到居然谷歌识图就出来了

### [](#header-33)题目: 精装四合一

首先，通察四张卡牌的文件末尾，发现这四个png在IEND后都有一大堆未知数据.  
观察这些数据发现，这四段数据的开头都是AE 42 60 82

![avatar](/image/2024-05-01-6.png)  

在bing搜索文件头无果后，遂开始分析文件内容. 发现数据中包含了太多的FF，因此推测整段数据应该被 FF 异或过，遂选择将四段数据都异或进行分析  

好巧不巧，异或后本来想截取前几个字符找找规律的，没想到一打印就找到规律了

```py
b'P\x14'
b'K\x00'
b'\x03\x01'
b'\x04\x00'
```

如上图所示，按图片顺序从上到下观察，第一个字节的排列是50(P) 4B(K) 03 04，这不就是zip文件头吗？  
遂马上写脚本，先将图片按顺序改名为1.png 2.png 3.png 4.png后再自动异或，而后将四个文件的字节穿插构造一个新文件

```py
#by leeya_bug
import binascii

text = []

def int2byte(a: int) -> bytes:
    b = hex(a).split('0x')[1]
    return binascii.a2b_hex(b.rjust(2, '0'))

for num in range(1, 5):
    with open(f'{num}.png', 'rb') as f:
        a2 = b''
        a = f.read()
        a1 = a.split(b'IEND')[1]
        for i in a1:
            a2 += int2byte(i ^ 0xff)
    text.append(a2[4:])

with open(f'res.zip', 'wb') as f:
    for i in range(0, len(text[0])):
        for num in range(0, 4):
            f.write(int2byte(text[num][i]))

```

运行脚本后，得到一个res.zip的文件，遂使用Arch爆破，密码是：65537  
(在此，熟悉密码学的同学应该稍微有点反应了. 65537不就是常用的e吗？)

然后解压出来以后得到一个单word文档，如下所示

![avatar](/image/2024-05-01-8.png)  

直接以压缩包形式打开，首先观察/word/document.xml，发现有一段神秘数字: 
16920251144570812336430166924811515273080382783829495988294341496740639931651

![avatar](/image/2024-05-01-9.png)  

将这段数字质数分解，发现能分为
100882503720822822072470797230485840381 * 167722355418488286110758738271573756671，也就是 p 和 q

然后观察到，/word/media/true_flag.jpeg 疑似为被加密的文件. 那现在就好办了，直接写个脚本解密就行了

```py
#by leeya_bug
from Crypto.Util.number import *
import gmpy2

e = 65537
n = 16920251144570812336430166924811515273080382783829495988294341496740639931651
p = 100882503720822822072470797230485840381
q = 167722355418488286110758738271573756671
phi = (p - 1) * (q - 1)
d = gmpy2.invert(e, phi)
with open('true_flag.jpeg', 'rb') as f:
    c = bytes_to_long(f.read())
m = pow(c, d, n)
print(long_to_bytes(m))
```

得到flag

### [](#header-33)题目: osint2

![avatar](/image/2024-05-01-91.png)  

首先拿到这张图，一看就是洛阳 - 泸州线路

在携程上查，车辆必然只有 G3292/G3293 这两列车，因此第一段 flag 就出来了

洛阳属于河南省，则第二段 flag 出来了，而洛阳的景点暂时无法判断，因此根据周边景点一个个慢慢拼接flag来猜. 最后终于猜到了洛阳老君山

flag：XYCTF{G3293/河南省/老君山}

