---
title: DASCTF 2024-Pub 个人部分题解
published: true
---

| 目录跳转: |
|--------|
| [PWN题目: sixbytes](#pwn题目-sixbytes) |
| [PWN题目: usersys(未更完)](#pwn题目-usersys) |

# [](#header-3)pwn题目 sixbytes

进入 main 函数，调用函数读取 flag 而后赋值给 v4，v4 即为 flag 的字符串首地址，函数笔者不再赘述. 接下来进入 sub_5555555553B8 看 v3 的生成方式

![dasctf](/image/dasctf2024/1.png)  

sub_5555555553B8:   
可以观察到，该函数使用 mmap 在 0x20240000 申请了权限为 0x7 (可读可写可执行) 的较长空间后，再读取了 6 个字节的用户输入数据到该空间内. 这里限制了用户只能输入六个字节的数据

![dasctf](/image/dasctf2024/2.png)  

最后在主函数以 v4 为参数调用该空间. 即将 PC 更改到用户输入数据的头部

![dasctf](/image/dasctf2024/3.png)  

一开始我的思路是 _perror 直接输出 flag，看了一下后发现开启了 seccomp 禁止了 syscall

![dasctf](/image/dasctf2024/4.png)  

由于没任何输入输出，只能靠盲注：

如下所示，当 [rdi + i] 的值大于 X 时则跳转，进入到死循环，否则 Segment Error. 这样就可以写个二分盲注，盲注出结果

`payload`

```x64
loop:
cmp byte ptr[rdi + i], X
jg loop
```

而正巧的是，该 payload 占长度为 5 字节，不超过 6 字节. 因此是可行的

exp 后面再放

# [](#header-3)pwn题目 usersys

等会更新
